{
    "collab_server" : "",
    "contents" : "# Modern Statistical Workflow  {#intro}\n\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(eval = F)\n```\n\nThis session introduces the process I recommend for model building, which I call \"Modern Statistical Workflow\".\n\n## Modern Statistical Workflow\n\nThe workflow described here is a template for all the models that will be discussed during the course.\nIf you work by it, you will learn models more thoroughly, spot errors more swiftly, and build\na much better understanding of economics and statistics than you would under a less rigorous\nworkflow.\n\nThe workflow is iterative. Typically we start with the simplest possible model, working through\neach step in the process. Only once we have done each step do we add richness to the model. Building\nmodels up like this in an iterative way will mean that you always have a working version of a model\nto fall back on. The process is:\n\n   1. Write out a full probability model. This involves specifying the joint distribution for your\n   parameters/latent variables and the conditional distribution for the outcome data.\n   2. Simulate some data from the model with assumed values for the parameters (these might be quite \n   different from the \"true\" parameter values).\n   3. Estimate the model using the simulated data. Check that your model can recover the known\n   parameters used to simulate the data.\n   4. Estimate the model parameters conditioned on real data.\n   5. Check that the estimation has run properly.\n   6. Run posterior predictive checking/time series cross validation to evaluate model fit.\n   7. Perform predictive inference.\n\nIterate the entire process to improve the model! Compare models---which model are the observed outcomes more plausibly drawn from?\n\n### Example: A model of wages\n\nBefore building any model, it is always worth writing down the questions that we might want to ask.\nSometimes, the questions will be relativey simple, like \"what is the difference in average wages between\nmen and women?\" Yet for most large-scale modeling tasks we want to build models capable of answering \nmany questions. In the case of wages, they may be questions like:\n\n- If I know someone is male and lives in the South what should I expect their wages to be, holding \nother personal characteristics constant? \n- How much does education affect wages?\n- Workers with more work experience tend to earn higher wages. How does this effect vary across demographic groups?\n- Does variance in wages differ across demographic groups?\n\nAs a good rule of thumb, the more questions you want a model to be able to answer, the more complex\nthe model will have to be. The first question above might be answered with a simple linear regression model, the second, \na more elaborate model that allows the relationship between experience and wages to vary across demographic\ngroups; the final question might involve modeling the variance of the wage distribution, not just its mean.\n\nThe example given below introduces a simple linear model of wages given demographic characteristics, with the intent\nof introducing instrumental variables---the first trick up our sleeve for the day. We'll introduce two competing\ninstrumental variables models: the first assuming independence between the first and second stage regressions and the\nsecond modeling them jointly. \n\nLet's walk through each step of the workflow, gradually introducing Stan along the way. While we're not going\nto estimate the model on real data, we want to make sure that the model we build is sane. As such we'll look at\nthe characteristics of wages for some real data. This data comes from some wage and demographics data from the \n1988 Current Population Survey, which comes in R's `AER` package. This dataset contains the weekly wage for \naround 28,000 working men in 1988; prices are in 1992 dollars. You can load the dataset into your R workspace \nlike so: \n\n```{r, eval =T}\nlibrary(AER)\ndata(\"CPS1988\")\n```\n\n\n### Step 1: Writing out the probability model\n\nThe first step of of our workflow is to propose an underlying generative model. It's helpful to think \nof a generative model as being a structured random number generator, which when simulated, \ngenerates outcomes with a distribution that looks like the distribution of the outcome variable. \nOnce we have decided on the generative model, we then get into the specifics of endogeneity issues etc. \nIn deciding the choice of distribution to use, you should plot a histogram or density of the \noutcome. For example, we could generate a histogram of wages like so: \n\n```{r, message = F, warning = F, fig.height=2, fig.width=3, eval = T}\nlibrary(ggplot2)\nggplot(CPS1988, aes(x = log(wage))) +\n  geom_histogram() + \n  ggthemes::theme_economist(base_size = 12) +\n  ggtitle(\"Histogram of log of wages\")\n\n```\n\nAs we can see, the distribution of wages is quite skewed, and so we might need to choose a\ndistribution capable of generating highly skewed outcomes. Another approach is to transform the data. \nIn this case, because all wages are positive, we could take their natural log. The distribution of log wages\nappears to be far more normal than the initial distribution, and it possible that the non-normality is explainable\nusing demographic characteristics. \n\n```{r, message = F, warning = F, fig.height=2, fig.width=3, eval = T}\nggplot(CPS1988, aes(x = log(wage))) +\n  geom_histogram() + \n  ggthemes::theme_economist(base_size = 12) +\n  ggtitle(\"Histogram of log of wages\")\n\n```\n\nIf we decide to choose a normal density as the data-generating process, and assume that the conditional distribution\nof one person's wage does not depend on the conditional distribution of another person's, we can write it out like so: \n\n$$\n\\log(\\mbox{wage})_{i} \\sim \\mbox{Normal}(\\mu_{i}, \\sigma_{i})\n$$\n\nwhich says that a person $i$'s wage is distributed according to a normal distribution \nwith _location_ $\\mu_{i}$ and _scale_ $\\sigma_{i}$. In the case of a normal density, the location is the\nmean, and the scale is the standard deviation. We prefer to use \"location\" and \"scale\" rather than \n\"mean\" and \"standard deviation\" because the terminology can carry across to other densities whose \nlocation and scale parameters don't correspond to the mean or standard deviation. \n\nLet's be clear about what this means. This generative model says that each individual's (log) wage is not completely\ndetermined---it involves some amount of luck. So while on average it will be $\\mu_{i}$, luck will result in differences\nfrom this average, and these differences have a standard deviation of $\\sigma_{i}$.\n\nNotice that both parameters $\\mu_{i}$ and $\\sigma_{i}$ vary across each individual. One of the\nmain challenges of building a good model is to come up with functional forms for $\\mu_{i}$ and $\\sigma_{i}$, \ntaking into account the information available to us. For instance, the (normal) linear regression model uses a \n(row) vector of individual characteristics $X_{i} = (\\mbox{education}_{i},\\mbox{experience}_{i}, \\dots)$, along with\na set of parameters that are common to all individuals (an intercept $\\alpha$, coefficients $\\beta$ and a scale parameter $\\sigma$). \nThe generative model is then:\n\n$$\n\\log(\\mbox{wage})_{i} \\sim \\mbox{Normal}(\\alpha + X_{i}\\beta, \\sigma)\n$$\nwhich is the same as saying: \n\n$$\n\\log(\\mbox{wage})_{i} = \\alpha + X_{i}\\beta + \\epsilon_{i} \\mbox{ with } \\epsilon_{i} \\sim \\mbox{N}(0, \\sigma)\n$$\n\n\nNote that we've made \"modeling assumptions\" $\\mu_{i} = \\alpha + X_{i}\\beta$ and $\\sigma_{i} = \\sigma$. \nThe parameters of the generative model are both \"true\" and unknown. The entire point is to peform inference\nin order to get probabilistic estimates of the \"true\" parameters. \n\n#### Choosing the right generative model\n\nAbove, we picked out a normal density for log wages (which corresponds to a lognormal density for wages) as \na reasonable first step in modeling our wage series. How did we get to this choice? The choice of distribution \nto use should depend on the nature of your outcome variables. Two good rules of thumb are: \n\n1. The chosen distribution should not give positive probability to impossible outcomes. For example, wages can't \nbe negative, and so if we were to use a normal density (which gives positive probability to all outcomes) to \nmodel wages, we would be committing an error. If an outcome is outcome is binary or count data, the model should not \ngive weight to non-integer outcomes. And  so on. \n2. The chosen distribution should give positive weight to plausible outcomes. \n\n#### Choosing priors\n\nTo complete our probability model, we need to specify priors for the parameters $\\beta$ and $\\sigma$. Again, these priors should place positive probabilistic weight over values of the parameters that\nwe consider possible, and zero weight on impossible values (like a negative scale $\\sigma$). In this case, \nit is common to assume normal priors for regression coefficients and half-Cauchy or half-Student-t priors on scales. \n\nA great discussion of choosing priors is available [here](github.com/stan-dev/wiki). \n\n#### Thinking ahead: are our data endogenous? Instrumental variables\n\nAs you will see in the generative model above, $\\epsilon$ are as though they've been drawn from a (normal) random \nnumber generator, and have no systematic relationship to the variables in X. Now what is the economic meaning\nof $\\epsilon$? The way I prefer to think about it is as a catch-all containing the unobserved information that is\nrelevant to the outcome. \n\nWe need to think ahead: is there unobserved information that will be systematically correlated with $X$? Can\nwe tell a story that there are things that cause both some change in one of our $X$ variables and also our\nobserved wages? If such information exists, then at the model estimation stage we will  have an unobserved \nconfounder problem, and we need to consider it in our probability model. A common way of achiving this is to \nuse instrumental variables. \n\nAn instrumental variable is one that introduces plausible exogenous variation into our endogenous regressor. \nFor example, if we have years of education on the right hand side, we might be concerned that the same \nsorts of unobserved factors---family and peer pressure, IQ etc.---that lead to high levels of education \nmight also lead to high wages (even in absense of high levels of education). In this case we would want \nto \"instrument\" education, ideally with an experimental treatment that randomly assigned some people to \nhigher rates of education and others to less. In reality, such an experiment might not be possible to run, \nbut we might find \"natural experiments\" that result in the same variation. The most famous case of such\nan instrument is the Vietnam war draft (Angrist and Kreuger, 1992). \n\nThere are a few ways of incorporating instrumental variables. The first is so-called \"two stage least squares\"\nin which we first regress the endogenous regressor on the exogenous regressors ($X_{edu,i}$) plus an instrument or instruments $Z_{i}$. \nIn the second stage we replace the actual values of education with the fitted values from the first stage. \n\nStage one: \n\n$$\n\\mbox{education}_{i} \\sim \\mbox{Normal}(\\alpha_{s1} + X_{-edu,i}\\gamma + Z_{i}\\delta, \\sigma_{s1})\n$$\nStage two: \n\n$$\n\\log(wage_{i})  \\sim \\mbox{Normal}(\\alpha_{s2} + X_{-edu,i}\\beta + (\\alpha_{s1} + X_{-edu,i}\\gamma + Z_{i}\\delta)\\tau, \\sigma_{s2})\n$$\n(In the second stage, we only estimate $\\alpha_{s2}, \\beta, \\tau$ and $\\sigma_{s2}$; the other parameters' values are from\nthe first stage). \n\nIf we treat the uncertainty of the first model approproately in the second (as is automatic in Bayes), then two stage\nleast squares yields an consistent estimate of the treatment effect $\\tau$ (that is, as the number of observations grows,\nwe get less bias). But it may be inefficient in the case when the residuals of the data generating processes in stage one\nand stage two are correlated. \n\nThe second method of implementing instrumental variables is as a simultaneous equations model. Under this framework, \nthe generative model is \n\n$$\n(\\log(wage_{i}), \\mbox{edu}_{i})' \\sim \\mbox{Multi normal}\\left((\\mu_{1,i}, \\mu_{2, i})', \\Sigma\\right)\n$$\nwhere\n\n$$\n\\mu_{1,i} = \\alpha_{s2} + X_{-edu,i}\\beta + (\\alpha_{s1} + X_{-edu,i}\\gamma + Z_{i}\\delta)\\tau\n$$\nand \n$$\n\\mu_{2,i} = \\alpha_{s1} + X_{-edu,i}\\gamma + Z_{i}\\delta\n$$\nYou will see: this is the same as the two stage least squares model above, exept we have allowed the errors to be\ncorrelated across equations (this information is in the covariance matrix $\\Sigma$). Nobody really understands\nraw numbers from Covariance matrices, so we typically decompose covariance into the more interpretable  \nscale vector $\\sigma$ and correlation matrix $\\Omega$ such that $\\Sigma = \\mbox{diag}(\\sigma)\\Omega \\mbox{diag}(\\sigma)$.\nThis decomposition also allows us to use more interpretable priors. \n\nWe now have two possible models. What we'll do below is simulate data from the second model with known parmaters. \nThen we'll code up both models and estimate each, allowing us to perform model comparison. \n\n### Step 2: Simulating the model with known parameters\n\nWe have now specified two probability models. What we will do next is simulate some data from the second (more complex model), and then check to see if we can recover the (known) model parameters by estimating both the correctly specified and incorrectly specified models above. Simulating and recovering known parameters is an important checking procedure in model building; it often helps catch errors in the model and clarifies the model in the mind of the modeler. \n\nNow that we have written out the data generating model, let's generate some known parameters and covariates and simulate the model. First: generate some values for the data and paramaters.\n\n\n```{r}\n# Generate a matrix of random numbers, and values for beta, nu and sigma\n\nset.seed(48) # Set the random number generator seed so that we get the same parameters\nN <- 500 # Number of observations\nP <- 5 # Number of covariates\nX <- matrix(rnorm(N*P), N, P) # generate an N*P covariate matrix of random data\nZ <- rnorm(N) # an instrument\n\n# The parameters governing the residuals\nsigma <- c(1, 2)\nOmega <- matrix(c(1, .5, .5, 1), 2, 2)\n\n# Generate some residuals\nresid <- MASS::mvrnorm(N, mu = c(0, 0), Sigma = diag(sigma)%*% Omega %*% diag(sigma))\n\n# Now the parameters of our model\nbeta <- rnorm(P)\ntau <- 1 # This is the treatment effect we're looking to recover\nalpha_1 <- rnorm(1)\nalpha_2 <- rnorm(1)\ngamma <- rnorm(P)\ndelta <- rnorm(1)\n\nmu_2 <- alpha_1 + X%*%gamma + Z*delta\nmu_1 <- alpha_2 + X%*%beta + mu_2*tau\n\nY <- as.numeric(mu_1 + resid[,1])\nendog_regressor <- as.numeric(mu_2 + resid[,2])\n\n# And let's check we can't recapture with simple OLS: \n\nlm(Y ~ . + endog_regressor, data = as.data.frame(X))\n\n```\n\n### Writing out the Stan model to recover known parameters\n\nA Stan model is comprised of code blocks. Each block is a place for a certain task. The bold blocks below must be present in all Stan programs (even if they contain no arguments):\n\n1. `functions`, where we define functions to be used in the blocks below. This is where we will write out a random number generator that gives us draws from our assumed model.\n2. `data`, declares the data to be used for the model\n3. `transformed data`, makes transformations of the data passed in above\n4. `parameters`, defines the unknowns to be estimated, including any restrictions on their values.\n<!-- jgabry: Is \"defines\" right for the parameters block? Or would \"declares\" be more precise? -->\n5. `transformed parameters`, often it is preferable to work with transformations of the parameters and data declared above; in this case we define them here.\n6. `model`, where the full probability model is defined.\n7. `generated quantities`, generates a range of outputs from the model (posterior predictions, forecasts, values of loss functions, etc.).\n\n\n```{r}\n# In R:\n# Load necessary libraries and set up multi-core processing for Stan\noptions(warn=-1, message =-1)\nlibrary(dplyr); library(ggplot2); library(rstan); library(reshape2)\noptions(mc.cores = parallel::detectCores())\n```\n\n\nNow we have $y$ and $X$, and we want to estimate $\\beta$, $\\sigma$ and, depending on the model, $\\nu$. We have two candidate probability models that we want to estimate and check which one is a more plausible model of the data. To do this, we need to specify both models in Stan and then estimate them.\n\nLet's jump straight in and define the incorrectly specified model. It is incorrect in that we haven't properly accounted\nfor the mutual information in first and second stage regressions. \n\n```\n// saved as models/independent_iv.stan\n// saved as models/independent_iv.stan\ndata {\n  int N; // number of observations\n  int P; // number of covariates\n  matrix[N, P] X; //covariate matrix\n  vector[N] Y; //outcome vector\n  vector[N] endog_regressor; // the endogenous regressor\n  vector[N] Z; // the instrument (which we'll assume is a vector)\n}\nparameters {\n  vector[P] beta; // the regression coefficients\n  vector[P] gamma;\n  real tau;\n  real delta;\n  real alpha_1;\n  real alpha_2;\n  vector<lower = 0>[2] sigma; // the residual standard deviation\n  corr_matrix[2] Omega;\n}\ntransformed parameters {\n  matrix[N, 2] mu;\n  \n  for(i in 1:N) {\n    mu[i,2] = alpha_1 + X[i]*gamma + Z[i]*delta;\n    mu[i,1] = alpha_2 + X[i]*beta + mu[i,2]*tau;\n  }\n}\nmodel {\n  // Define the priors\n  beta ~ normal(0, 1); \n  gamma ~ normal(0, 1);\n  tau ~ normal(0, 1);\n  sigma ~ cauchy(0, 1);\n  delta ~ normal(0, 1);\n  alpha_1 ~ normal(0, 1);\n  alpha_2 ~ normal(0, 2);\n  Omega ~ lkj_corr(5);\n  \n  // The likelihood\n  for(i in 1:N) {\n    Y[i]~ normal(mu[i], sigma[1]);\n    endog_regressor[i]~ normal(mu[2], sigma[2]);\n  }\n\n  \n}\ngenerated quantities {\n  // For model comparison, we'll want to keep the likelihood\n  // contribution of each point\n\n  vector[N] log_lik;\n  for(i in 1:N) {\n    log_lik[i] = normal_lpdf(Y[i] | alpha_1  + X[i,] * beta + endog_regressor[i]*tau, sigma[1]);\n  }\n}\n\n```\n\nNow we define the correctly specified model. It is the same as above, but with a couple of changes:\n\n```\n// saved as models/joint_iv.stan\n// saved as models/joint_iv.stan\ndata {\n  int N; // number of observations\n  int P; // number of covariates\n  matrix[N, P] X; //covariate matrix\n  vector[N] Y; //outcome vector\n  vector[N] endog_regressor; // the endogenous regressor\n  vector[N] Z; // the instrument (which we'll assume is a vector)\n}\nparameters {\n  vector[P] beta; // the regression coefficients\n  vector[P] gamma;\n  real tau;\n  real delta;\n  real alpha_1;\n  real alpha_2;\n  vector<lower = 0>[2] sigma; // the residual standard deviation\n  corr_matrix[2] Omega;\n}\ntransformed parameters {\n  matrix[N, 2] mu;\n  \n  for(i in 1:N) {\n    mu[i,2] = alpha_1 + X[i]*gamma + Z[i]*delta;\n    mu[i,1] = alpha_2 + X[i]*beta + mu[i,2]*tau;\n  }\n}\nmodel {\n  // Define the priors\n  beta ~ normal(0, 1); \n  gamma ~ normal(0, 1);\n  tau ~ normal(0, 1);\n  sigma ~ cauchy(0, 1);\n  delta ~ normal(0, 1);\n  alpha_1 ~ normal(0, 1);\n  alpha_2 ~ normal(0, 2);\n  Omega ~ lkj_corr(5);\n  \n  // The likelihood\n  {\n    matrix[N, 2] Y2;\n    Y2 = append_col(Y, endog_regressor);\n    for(i in 1:N) {\n      Y2[i]~ multi_normal(mu[i], diag_matrix(sigma)*Omega*diag_matrix(sigma));\n    }\n  }\n  \n}\ngenerated quantities {\n  // For model comparison, we'll want to keep the likelihood\n  // contribution of each point\n\n  vector[N] log_lik;\n  for(i in 1:N) {\n    log_lik[i] = normal_lpdf(Y[i] | alpha_1  + X[i,] * beta + endog_regressor[i]*tau, sigma[1]);\n  }\n}\n\n```\n\nNow that we have specified two models, let's estimate them with the $y$ and $X$ we generated above.\n\n\n```{r, results = \"hide\"}\n# In R\n\nincorrect_fit <- stan(file = \"models/independent_iv.stan\",\n                      data = list(Y = Y,\n                                  X = X,\n                                  endog_regressor = endog_regressor,\n                                  P = P, \n                                  N = N,\n                                  Z = Z), \n                      iter = 600)\ncorrect_fit <- stan(model_code = \"models/joint_iv.stan\",\n                    data = list(Y = Y,\n                                X = X,\n                                endog_regressor = endog_regressor,\n                                P = P, \n                                N = N,\n                                Z = Z),\n                    iter = 600)\n```\n\n\nWe have now fit our two competing models to the data. What has been estimated?\n\n#### What do these fitted objects contain?\n\nIf you are accustomed to estimating models using ordinary least squares (OLS), maximum likelihood estimates (MLE), or the general method of moments (GMM), then you may expect point estimates for parameters: regression tables contain an estimate of the parameter along with some standard errors. Full Bayesian inference involves averaging over the uncertainty in parameter estimates, that is, the posterior distribution.  For a point estimate, Bayesians typically use the mean of the posterior distribution, because it minimizes expected square error in the estimate; the posterior median minimizes expected absolute error.\n\nFor all but a few models, posterior distributions cannot be expressed analytically.  Instead, numerical techniques involving simulation going under the general heading of Monte Carlo methods, are used to estimate quantities of interest by taking draws from the distribution in question.\n\nMonte Carlo estimation is quite simple. Let's say a parameter $\\theta$ is distributed according to some distribution  $\\mbox{Foo}(\\theta)$ for which we have no analytical formula, but from which we can simulate random draws.  We want to draw statistical inferences using this distribution; we want its mean (expected value), standard deviation, median and other quantiles for posterior intervals, etc. The Monte Carlo method allows us to make these inferences by simply generating many (not necessarily independent) draws from the distribution and then calculating the statistic of interest from those draws. Because these draws are from the distribution of interest, they will tend to come from the higher probability regions of the distribution.  For example, if 50\\% of the posterior probability mass is near the posterior mode, then 50\\% of the simulated draws (give or take sampling error) should be near the posterior mode.\n\nFor example, suppose we want to estimate the expectation of $\\mbox{Foo}(\\theta)$, or in other words, the mean of a variable $\\theta$ with distribution $\\mbox{Foo}(\\theta)$. If we take $M$ random draws from $\\mbox{Foo}$,\n\\[\n\\theta^{(1)}, \\ldots, \\theta^{(M)} \\sim \\mbox{Foo}(),\n\\]\nthen we can estimate the expected value of $\\theta$ (i.e., its posterior mean) as\n\\[\n\\mathbb{E}[\\theta]\n\\approx\n\\frac{1}{M} \\sum_{m=1}^{M} \\theta^{(m)}.\n\\]\n\nIf the draws $\\theta^{(m)}$ are independent, the result is a sequence of independent and identically distributed (i.i.d.) draws.  The mean of a sequence of i.i.d. draws is governed by the central limit theorem, where the standard error on the estimates is given by the standard deviation divided by the square root of the number of draws.  Thus standard error decreases as $\\mathcal{O}(\\frac{1}{\\sqrt{M}})$ in the number of independent draws $M$.\n\nWhat makes Bayesian inference not only possible, but practical, is that almost all of the Bayesian inference for event probabilities, predictions, and parameter estimates can be expressed as expectations and carried out using Monte Carlo methods.\n\nThere is one hitch, though.  For almost any practically useful model, not only will we not be able to get an analytical formula for the posterior, we will not be able to take independent draws.  Fortunately, all is not lost, as we will be able to take identically distributed draws using a technique known as Markov chain Monte Carlo (MCMC).  With MCMC, the draws from a Markov chain in which each draw $\\theta^{(m+1)}$ depends (only) on the previous draw $\\theta^{(m)}$.  Such draws are governed by the MCMC central limit theorem, wherein a quantity known as the effective sample size plays the role of the effective sample size in pure Monte Carlo estimation.  The effective sample size is determined by how autocorrelated the draws are;  if each draw is highly correlated with previous draws, then more draws are required to achieve the same effective sample size.\n\nStan is able to calculate the effective sample size for its MCMC methods and use that to estimate standard errors for all of its predictive quantities, such as parameter and event probability estimates.\n\nA fitted Stan object contains a sequence of $M$ draws, where each draw contains a value for every parameter (and generated quantity) in the model.  If the computation has converged, as measured by built-in convergence diagnostics, the draws are from the posterior distribution of our parameters conditioned on the observed data.  These are draws from the joint posterior distribution; correlation between parameters is likely to be present in the joint posterior even if it was not present in the priors.\n\nIn the generated quantities block of the two models above, we declare variables for two additional quantities of interest.\n\n- The first, `log_lik`, is the log-likelihood, which we use for model comparison.  We obtain this value for each parameter draw, for each value of $y_{i}$. Thus if you have $N$ observations and `iter` parameter draws, this will contain $N\\times$ `iter` log-likelihood values (which may produce a lot of output for large data sets).\n\n- The second, `y_sim`, is a _posterior predictive quantity_, in this case a replicated data set consisting of a sequence of fresh outcomes generated randomly from the parameters. Rather than each observation having a \"predicted value\", it has a predictive distribution that takes into account both the regression residual and uncertainty in the parameter estimates.\n\n\n### Model inspection\n\n\nTo address questions 1 and 2 above, we need to examine the parameter draws from\nthe model to check for a few common problems:\n\n- **Lack of mixing**. A poorly \"mixing\" Markov chain is one that moves very\nslowly between regions of the parameter space or barely moves at all. This can\nhappen if the distribution of proposals is much narrower than the target\n(posterior) distribution or if it is much wider than the target distribution. In\nthe former case most proposals will be accepted but the Markov chain will not\nexplore the full parameter space whereas in the latter case most proposals will\nbe rejected and the chain will stall. By running several Markov chains from\ndifferent starting values we can see if each chain mixes well and if the chains\nare converging on a common distribution. If the chains don't mix well then it's\nunlikely we're sampling from a well specified posterior. The most common reason\nfor this error is a poorly specified model.\n- **Stationarity**. Markov chains should be covariance stationary, which means\nthat the mean and variance of the chain should not depend on when you draw the\nobservations. Non-stationarity is normally the consequence of a poorly specified\nmodel or an insufficient number of iterations.\n- **Autocorrelation**. Especially in poorly specified or weakly identified\nmodels, a given draw of parameters can be highly dependent on the previous draw\nof the parameters. One consequence of autocorrelation is that the posterior\ndraws will contain less information than the number of draws suggests. That is,\nthe effective posterior sample size will be much less than the actual\nposterior sample size. For example, 2000 draws with high autocorrelation will be\nless informative than 2000 independent draws. Assuming the model is specified\ncorrectly, then _thinning_ (keeping only every k-th draw) is one common approach\nto dealing with highly autocorrelated draws. However, while thinning can reduce\nthe autocorrelation in the draws that are retained it still sacrifices\ninformation. If possible, [reparameterising the\nmodel](http://mc-stan.org/documentation/) is a better approach to this problem.\n(See section 21 of the manual, on Optimizing Stan code).\n- **Divergent transitions**. In models with very curved or irregular posterior\ndensities, we often get \"divergent transitions\". This typically indicates that\nthe sampler was unable to explore certain regions of the distribution and a\nrespecification or changes to the sampling routine may be required. The easiest\nway of addressing this issue is to use\n`control = list(adapt_delta = 0.99)`\nor some other number close to 1. This will lead to smaller step sizes and\ntherefore more steps will be required to explore the posterior. Sampling will be\nslower but the algorithm will often be better able to explore these problematic\nregions, reducing the number of divergent transitions.\n\nAll of these potential problems can be checked using the ShinyStan graphical\ninterface, which is available in the `shinystan` `R` package. You can install it\nwith `install.packages(\"shinystan\")`, and run it with\n`launch_shinystan(correct_fit)`. It will bring up an interactive\nsession in your web browser within which you can explore the estimated\nparameters, examine the individual Markov chains, and check various diagnostics.\nMore information on ShinyStan is available\n[here](http://mc-stan.org/interfaces/shinystan). We will confront most of these\nissues and show how to resolve them in later chapters when we work with real\nexamples. For now just keep in mind that MCMC samples always need to be checked\nbefore they are used for making inferences.\n\n\n\n### Model comparison\n\nLet's start by looking at the model outputs. The draws from each parameter can be neatly summarized with `print`:\n\n\n```{r}\n# In R:\n\nprint(incorrect_fit, pars = c(\"beta\", \"tau\", \"sigma\"))\n# specify parameters to save; else we'd get `log_lik` and `y_sim`\n\n# Some things to note:\n\n# - mean is the mean of the draws for each observation\n# - se_mean is the Monte Carlo error\n#   (standard error of the Monte Carlo estimate from the true mean)\n# - sd is the standard deviation of the parameter's draws\n# - the quantiles are self-explanatory\n# - n_eff is the effective number of independent draws.\n#   If there is serial correlation between sequential draws,\n#   the draws cannot be considered independent.\n#   In Stan, high serial correlation is typically a problem in\n#   poorly specified models\n# - Rhat: this is the Gelman Rubin convergence diagnostic.\n#   Values close to 1 indicate that the multiple chains\n#   that you estimated have converged to the same\n#   distribution and are \"mixing\" well.\n```\n\n\n\n```{r}\n# In R\n\nprint(correct_fit, pars = c(\"beta\", \"sigma\", \"nu\"))\n```\n\n\nAt the moment, it seems as though both our models have done about as good a job at estimating the regression coefficients $\\beta$ as one another. But the incorrectly specified model severely overestimates $\\sigma$. This makes sense--a Student-t distribution with $\\nu=5$ will have fat tails, and so a normal distribution will try to replicate the extreme values by having a large variance.\n\nHow else might we compare the two models?\n\nOne approach is to use the `loo` package to compare the models on their\nestimated out-of-sample predictive performance. The idea of this package is to\napproximate each model's leave-one-out (LOO) cross-validation error, allowing\nmodel comparison by the LOO Information Criterion (LOOIC). LOOIC has the same\npurpose as the Akaike Information Criterion (AIC), which is to estimate the\nexpected log predictive density (ELPD) for a new dataset. However, AIC ignores\nprior distributions and makes the assumption that the posterior is a\nmultivariate normal distribution. The approach taken by the `loo` package does\nnot make this distributional assumption and also integrates over (averages over)\nthe uncertainty in the parameters.\n\nThe Bayesian LOO estimate is\n$\\sum_{n = 1}^{N}\\log p(y_{n} \\, | \\, y_{1}, ..., y_{n-1}, y_{n+1}, ..., y_{N})$,\nwhich requires fitting the model $N$ times, each time leaving out one of the $N$\ndata points. For large datasets or complex models the computational cost is\nusually prohibitive. The `loo` package does an approximation that avoids\nre-estimating the model and requires only the log-likelihood evaluated at the\nposterior draws of the parameters. The approximation will be good so long as the\nposterior distribution is not very sensitive to leaving out any single\nobservation.\n\nA big upside of this approach is that it enables us to generate probabilistic\nestimates of the degree to which each model is most likely to produce the\nbest out-of-sample predictions.\n\nWe use `loo` like so:\n\n```{r}\n# in R\n# \n# library(loo) # Load the library\n# \n# # Extract the log likelihoods of both models.\n# # Note that we need to declare log_lik in the generated quantities block\nllik_incorrect <- extract_log_lik(incorrect_fit, parameter_name = \"log_lik\")\nllik_correct <- extract_log_lik(correct_fit, parameter_name = \"log_lik\")\n# \n# # Estimate the leave-one-out cross validation error\nloo_incorrect <- loo(llik_incorrect)\nloo_correct <- loo(llik_correct)\n```\n```{r, results=\"hold\"}\n# # Print the LOO statistics\nprint(\"Incorrect model\")\nprint(loo_incorrect)\n```\n```{r, results=\"hold\"}\nprint(\"Correct model\")\nprint(loo_correct)\n```\n\nThe quantity `elpd_loo` is the expected log pointwise predictive density (ELPD).\nThe log pointwise predictive density is easiest to understand in terms of its\ncomputation. For each data point we compute the log of its average likelihood,\nwhere the average is computed over the posterior draws. Then we take the sum\nover all of the data points. We can multiply `elpd_loo` by $-2$ to calculate the\n`looic`, which you can think of like AIC or BIC, but coming from our Bayesian\nframework. The $-2$ is not important; it simply converts the value to the\nso-called deviance scale. The value of `p_loo` is the estimated effective number\nof parameters, which is a measure of model complexity. The effective number of\nparameters can be substantially less than the actual number of parameters when\nthere is strong dependence between parameters (e.g. in many hierarchical models)\nor when parameters are given informative prior distributions. For further\ndetails on these quantities, please consult [this\npaper](http://arxiv.org/abs/1507.04544).\n\n```{r}\n# Print the comparison between the two models\nprint(compare(loo_incorrect, loo_correct), digits = 2)\n```\n\nWhen using the `compare` function to compare two models the `elpd_diff` gives us\nthe difference in the ELPD estimates for the models. A positive `elpd_diff`\nindicates that the second model is estimated to have better out-of-sample\npredictive accuracy than the first, which is precisely what we expect in this\ncase. When comparing more than two models the `compare` function will order\nthe models by their ELPD estimates.\n\n\n## Tools of the trade: borrowing from software engineering\n\nBuilding economic and statistical models increasingly requires sophisticated\ncomputation. This has the potential to improve our modeling, but carries with\nit risks; as the complexity of our models grows, so too does the prospect of\nmaking potentially influential mistakes. The well-known spreadsheet error in\nRogoff and Reinhart's (Cite) paper---a fairly simple error in very public\npaper---was discovered. Who knows how many other errors exist in more complex,\nless scruitinized work?\n\nGiven the ease of making errors that substantively affect our models' outputs,\nit makes sense to adopt a workflow that minimizes the risk of such error happening.\nThe set of tools discussed in this section, all borrowed from software engineering,\nare designed for this purpose. We suggest incorporating the following into your\nworkflow:\n\n- Document your code formally. At the very least, this will involve commenting your\ncode to the extend where a colleague could read it and not have too many questions.\nIdeally it will include formal documentation of every function that you write.\n- When you write functions, obey what we might call \"Tinbergen's rule of writing software\":\n*one function, one objective*. Try not to write omnibus functions that conduct a large\npart of your analysis. Writing small, modular functions will allow you to use **unit testing**,\na framework that lets you run a set of tests automatically, ensuring that changing one\npart of your code base does not break other parts.\n- Use Git to manage your workflow. Git is a very powerful tool that serves several purposes.\nIt can help you back up your work, which is handy. It also allows you to view your codebase\nat periods when you *committed* some code to the code base. It lets you experiment on *branches*,\nwithout risking the main (\"production\") code base. Finally helps you work in teams; formalizing\na **code-review** procedure that should help catch errors.\n",
    "created" : 1484915144744.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4025148566",
    "id" : "90EFF911",
    "lastKnownWriteTime" : 1484904823,
    "last_content_update" : 1484904823,
    "path" : "~/Documents/BSEcon/Econ short course/01-modern_statistical_workflow.Rmd",
    "project_path" : "01-modern_statistical_workflow.Rmd",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}