left_join(fake_data %>% group_by(j) %>% summarise(true_value = first(mu_j)), by = "j") %>%
select(-j)
cor(effect_estimates)
effect_estimates %>%
select(-contains("lower"), -contains("upper")) %>%
melt(id = "true_value") %>%
ggplot(aes(x = value, colour = variable)) +
stat_ecdf() +
stat_ecdf(aes(x = true_value), colour = "black")
effect_estimates %>%
ggplot(aes(x = bayes_est, y = bayes_est)) +
geom_linerange(aes(ymin = bayes_lower, ymax = bayes_upper), colour = "orange") +
geom_line() +
geom_point(aes(y = true_value), alpha =0.5)
effect_estimates %>%
ggplot(aes(x = ml_est, y = ml_est)) +
geom_linerange(aes(ymin = ml_lower, ymax = ml_upper), colour = "orange") +
geom_line() +
geom_point(aes(y = true_value), alpha =0.5)
effect_estimates %>%
ggplot(aes(x = 1:nrow(effect_estimates), y = ml_est)) +
geom_linerange(aes(ymin = ml_lower, ymax = ml_upper), colour = "orange") +
geom_line() +
geom_point(aes(y = true_value), alpha =0.5)
effect_estimates %>%
arrange(ml_est) %>%
ggplot(aes(x = 1:nrow(effect_estimates), y = ml_est)) +
geom_linerange(aes(ymin = ml_lower, ymax = ml_upper), colour = "orange") +
geom_line() +
geom_point(aes(y = true_value), alpha =0.5)
effect_estimates %>%
arrange(ml_est) %>%
ggplot(aes(x = 1:nrow(effect_estimates), y = bayes_est)) +
geom_linerange(aes(ymin = bayes_lower, ymax = bayes_upper), colour = "orange") +
geom_line() +
geom_point(aes(y = true_value), alpha =0.5)
effect_estimates %>%
summarise(coverage_bayes = mean(true_value < bayes_upper & true_value > bayes_lower),
coverage_ml = mean(true_value < ml_upper & true_value > ml_lower))
predict(ml_model)
tt <- data_frame(ml = predict(ml_model),
bayes = predict(bayes_mod),
actual = fake_data$y)
tt <- data_frame(ml = predict(ml_model),
bayes = posterior_predict(bayes_mod),
actual = fake_data$y)
tt <- data_frame(ml = predict(ml_model),
bayes = posterior_predict(bayes_mod) %>% apply(2, mean),
actual = fake_data$y)
cor(tt)
tt <- data_frame(ml = predict(ml_model),
bayes = posterior_predict(bayes_mod) %>% apply(2, median),
actual = fake_data$y)
cor(tt)
# This script generates data from a random coefficients logit model
library(evd)
library(rstan)
options(mc.cores = parallel::detectCores())
# compiled_blp <- stan_model("models/blp.stan")
# expose_stan_functions("models/blp.stan")
# Create data -------------------------------------------------------------
# Dimensions
J <- 10
T <- 50
NS <- 500
P <- 3
P2 <- 1
D <- 3
# Simulate demographics
Omega_dem <- matrix(c(1, .5, .5, .5 , 1, .5, .5, .5, 1), D, D)
Scale_dem <- c(1,2,3)
Dem <- MASS::mvrnorm(NS, c(0, 0, 0), diag(Scale_dem) %*% Omega_dem %*% diag(Scale_dem))
# Simulate individual shocks
v <- rnorm(NS)
# Product characteristics
x <- cbind(1, matrix(rnorm(J*(P-1)), J, P-1))
#x <- matrix(rnorm(J*(P)), J, P)
# Simulate true parameters
alpha <- -1*abs(rnorm(1))
beta <- rnorm(P)
Pi <- matrix(rnorm((P+1)*D), P+1, D)
Sigma <- matrix(rnorm(P+1))
gamma1 <- rnorm(1)
gamma2 <- rnorm(1)
inst_scale <- abs(rnorm(1))
# Simulate prices
# Instrument
instrument <- matrix(rnorm(J*T), J*T, 1)
# Price
price <- gamma1 + gamma2 * instrument + rnorm(J*T, 0, inst_scale)
price_matrix <- matrix(price, T,J, byrow = T)
# Simulate structural shocks
Xi <- matrix(rnorm(J*T), T, J)
# Delta
delta <- matrix(NA, T, J)
for(i in 1:T) {
delta[i,] = t(alpha * price_matrix[i,] + x %*% beta + Xi[i,])
}
# Simulate customer demographics
Dem_array <- array(NA,dim =  c(T,NS, D))
for(i in 1:T) {
Dem_array[i,,] <- Dem
}
# Simulate customer utility for each market
customer_draws <- array(NA, dim = c(T, NS, J))
market_shares <- matrix(NA, T, J)
for(i in 1:T) {
random_shocks <-  Dem_array[i,,] %*% t(Pi) +  v %*% t(Sigma)
del <- matrix(rep(delta[i,], NS), NS, J, byrow = T)
for(j in 1:J) {
customer_draws[i,,j] <-  del[,j] + random_shocks %*% c(price_matrix[i,j], x[j,]) + rgumbel(NS)
}
customer_draws[i,,] <- exp(customer_draws[i,,]) / matrix(rep(rowSums(exp(customer_draws[i,,])), J), NS, J)
market_shares[i,] <- colMeans(customer_draws[i,,])
}
market_shares_est <- market_shares[,-J]
J_est <- J-1
price_est <- as.vector(t(price_matrix[,-J]))
instrument_est <- as.vector(t(matrix(instrument, T, J, byrow = T)[,-J]))
x_est <- x[-J,]
# Testing functions -------------------------------------------------------
# mu_it(x_t = x_est, p_t = price_est[1:(J-1)], D_i = Dem[1,], v_i = v[1], Pi = Pi, Sigma = Sigma)
#
# s1 <- shares(x_t = x_est, p_t = price_est[1:(J-1)], D = Dem, v = v, Pi = Pi, Sigma = Sigma, delta_t = log(market_shares[1,-J]) - log(1 - sum(market_shares[1,-J])))
# s1
# sum(s1)
# delta_1(observed_shares = market_shares_est[1,], x_t = x_est, p_t = price_est[1:(J-1)], D = Dem, v = v, Pi = Pi, Sigma = Sigma, tol = 1e-8)
#
# while(diff>1e-8){
#   s2 <- shares(x_t = x_est, p_t = price_est[1:(J-1)], D = Dem, v = v, Pi = Pi, Sigma = Sigma, delta_t = init)
#   init2 <- init + log(matrix(market_shares_est[1,])) - log(t(s2))
#   diff <- crossprod(init2 - init)
#   init <- init2
# }
# init
# Run model ---------------------------------------------------------------
compiled_blp_dirichlet <- stan_model("models/blp_dirichlet2.stan")
test_est <- optimizing(compiled_blp_dirichlet, data = list(J = J_est,
T = T,
NS = NS,
P = P,
P2 = P2,
D = D,
market_shares = market_shares,
price = price_est,
instruments = matrix(instrument_est),
x = x_est,
Dem = Dem_array,
lambda = exp(3),
lambda2 = 3))
pars <- test_est$par
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
gamma1
pars[grep("gamma1", names(pars))]
gamma2
pars[grep("gamma2", names(pars))]
test_est$par[1]
colMeans(matrix(pars[grep("predicted_shares", names(pars))], 20, 6))
colMeans(matrix(pars[grep("predicted_shares", names(pars))], 20, 9))
colMeans(matrix(pars[grep("predicted_shares", names(pars))], 20, 10))
colMeans(market_shares)
a <- colMeans(matrix(pars[grep("predicted_shares", names(pars))], 20, 10))
b <- colMeans(market_shares)
plot(a, b)
a <- as.vector(matrix(pars[grep("predicted_shares", names(pars))], 20, 10))
b <- as.vector(market_shares)
plot(a, b)
market_shares
a <- as.vector(matrix(pars[grep("predicted_shares", names(pars))], 50, 10))
b <- as.vector(market_shares)
plot(a, b)
a <- colMeans(matrix(pars[grep("predicted_shares", names(pars))], 50, 10))
b <- colMeans(market_shares)
plot(a, b)
test_est <- optimizing(compiled_blp_dirichlet, data = list(J = J_est,
T = T,
NS = NS,
P = P,
P2 = P2,
D = D,
market_shares = market_shares,
price = price_est,
instruments = matrix(instrument_est),
x = x_est,
Dem = Dem_array,
lambda = exp(3),
lambda2 = 3), draws= 1000)
test_est <- optimizing(compiled_blp_dirichlet, data = list(J = J_est,
T = T,
NS = NS,
P = P,
P2 = P2,
D = D,
market_shares = market_shares,
price = price_est,
instruments = matrix(instrument_est),
x = x_est,
Dem = Dem_array,
lambda = exp(3),
lambda2 = 3))
pars <- test_est$par
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
gamma1
pars[grep("gamma1", names(pars))]
gamma2
pars[grep("gamma2", names(pars))]
test_est$par[1]
a <- as.vector(matrix(pars[grep("predicted_shares", names(pars))], 50, 10))
b <- as.vector(market_shares)
plot(abs(a - b), as.vector(Xi))
plot(a - b, as.vector(Xi))
plot(b - a, as.vector(Xi))
plot(scale(b - a), as.vector(Xi))
cor(scale(b - a), as.vector(Xi))
pars <- test_est$par
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
gamma1
pars[grep("gamma1", names(pars))]
gamma2
pars[grep("gamma2", names(pars))]
test_est$par[1]
true_pars <- c(alpha, beta, Pi, Sigma, gamma1, gamma2, inst_scale)
par_estimates <- test_est$par[2:24]
plot(data.frame(true_pars, par_estimates))
lines(lm(-3:3 ~ -3:3))
abline(a = 0, b = 1)
test_est <- vb(compiled_blp_dirichlet, data = list(J = J_est,
T = T,
NS = NS,
P = P,
P2 = P2,
D = D,
market_shares = market_shares,
price = price_est,
instruments = matrix(instrument_est),
x = x_est,
Dem = Dem_array,
lambda = exp(3),
lambda2 = 3))
test_est
test_est
pars <- get_posterior_mean(test_est)[,5]
pars <- get_posterior_mean(test_est)[[,1]
pars <- test_est$par
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
gamma1
pars[grep("gamma1", names(pars))]
gamma2
pars[grep("gamma2", names(pars))]
test_est$par[1]
a <- as.vector(matrix(pars[grep("predicted_shares", names(pars))], 50, 10))
b <- as.vector(market_shares)
cor(scale(b - a), as.vector(Xi))
plot(as.vector(pars[grep(x = names(pars),"Xi")]), as.vector(Xi[,-J]))
plot(as.vector(test_est$par[grep(x = names(test_est$par),"Xi")]), as.vector(Xi[,-J]))
matrix(test_est$par[grep(x = names(test_est$par),"original_shares")], 20, 7)
matrix(test_est$par[grep(x = names(test_est$par),"predicted_shares")], 20, 8)
true_pars <- c(alpha, beta, Pi, Sigma, gamma1, gamma2, inst_scale)
par_estimates <- test_est$par[2:24]
plot(data.frame(true_pars, par_estimates))
abline(a = 0, b = 1)
pars <- get_posterior_mean(test_est)[,1]
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
gamma1
pars[grep("gamma1", names(pars))]
gamma2
pars[grep("gamma2", names(pars))]
test_est$par[1]
a <- as.vector(matrix(pars[grep("predicted_shares", names(pars))], 50, 10))
b <- as.vector(market_shares)
cor(scale(b - a), as.vector(Xi))
par_estimates <- pars[2:24]
true_pars <- c(alpha, beta, Pi, Sigma, gamma1, gamma2, inst_scale)
par_estimates <- pars[2:24]
plot(data.frame(true_pars, par_estimates))
abline(a = 0, b = 1)
compiled_blp_dirichlet <- stan_model("models/blp_dirichlet2.stan")
test_est_2 <- optimizing(compiled_blp_dirichlet, data = list(J = J_est,
T = T,
NS = NS,
P = P,
P2 = P2,
D = D,
market_shares = market_shares,
price = price_est,
instruments = matrix(instrument_est),
x = x_est,
Dem = Dem_array,
lambda = exp(3),
lambda2 = 3))
pars <- test_est$par
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
gamma1
pars[grep("gamma1", names(pars))]
gamma2
pars[grep("gamma2", names(pars))]
pars <- test_est$par
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
gamma1
pars[grep("gamma1", names(pars))]
gamma2
pars[grep("gamma2", names(pars))]
a <- as.vector(matrix(pars[grep("predicted_shares", names(pars))], 50, 10))
b <- as.vector(market_shares)
cor(scale(b - a), as.vector(Xi))
true_pars <- c(alpha, beta, Pi, Sigma, gamma1, gamma2, inst_scale)
par_estimates <- pars[2:24]
plot(data.frame(true_pars, par_estimates))
abline(a = 0, b = 1)
# Create data -------------------------------------------------------------
# Dimensions
J <- 10
T <- 50
NS <- 500
P <- 3
P2 <- 1
D <- 3
# Simulate demographics
Omega_dem <- matrix(c(1, .5, .5, .5 , 1, .5, .5, .5, 1), D, D)
Scale_dem <- c(1,2,3)
Dem <- MASS::mvrnorm(NS, c(0, 0, 0), diag(Scale_dem) %*% Omega_dem %*% diag(Scale_dem))
# Simulate individual shocks
v <- rnorm(NS)
# Product characteristics
x <- cbind(1, matrix(rnorm(J*(P-1)), J, P-1))
#x <- matrix(rnorm(J*(P)), J, P)
# Simulate true parameters
alpha <- -1*abs(rnorm(1))
beta <- rnorm(P)
Pi <- matrix(rnorm((P+1)*D), P+1, D)
Sigma <- matrix(rnorm(P+1))
gamma1 <- rnorm(1)
gamma2 <- rnorm(1)
inst_scale <- abs(rnorm(1))
# Simulate prices
# Instrument
instrument <- matrix(rnorm(J*T), J*T, 1)
# Price
price <- gamma1 + gamma2 * instrument + rnorm(J*T, 0, inst_scale)
price_matrix <- matrix(price, T,J, byrow = T)
# Simulate structural shocks
Xi <- matrix(rnorm(J*T), T, J)
# Delta
delta <- matrix(NA, T, J)
for(i in 1:T) {
delta[i,] = t(alpha * price_matrix[i,] + x %*% beta + Xi[i,])
}
# Simulate customer demographics
Dem_array <- array(NA,dim =  c(T,NS, D))
for(i in 1:T) {
Dem_array[i,,] <- Dem
}
# Simulate customer utility for each market
customer_draws <- array(NA, dim = c(T, NS, J))
market_shares <- matrix(NA, T, J)
for(i in 1:T) {
random_shocks <-  Dem_array[i,,] %*% t(Pi) +  v %*% t(Sigma)
del <- matrix(rep(delta[i,], NS), NS, J, byrow = T)
for(j in 1:J) {
customer_draws[i,,j] <-  del[,j] + random_shocks %*% c(price_matrix[i,j], x[j,]) + rgumbel(NS, loc = -.5772)
}
customer_draws[i,,] <- exp(customer_draws[i,,]) / matrix(rep(rowSums(exp(customer_draws[i,,])), J), NS, J)
market_shares[i,] <- colMeans(customer_draws[i,,])
}
market_shares_est <- market_shares[,-J]
J_est <- J-1
price_est <- as.vector(t(price_matrix[,-J]))
instrument_est <- as.vector(t(matrix(instrument, T, J, byrow = T)[,-J]))
x_est <- x[-J,]
# This script generates data from a random coefficients logit model
library(evd)
library(rstan)
options(mc.cores = parallel::detectCores())
# compiled_blp <- stan_model("models/blp.stan")
# expose_stan_functions("models/blp.stan")
# Create data -------------------------------------------------------------
# Dimensions
J <- 10
T <- 20
NS <- 200
P <- 3
P2 <- 1
D <- 3
# Simulate demographics
Omega_dem <- matrix(c(1, .5, .5, .5 , 1, .5, .5, .5, 1), D, D)
Scale_dem <- c(1,2,3)
Dem <- MASS::mvrnorm(NS, c(0, 0, 0), diag(Scale_dem) %*% Omega_dem %*% diag(Scale_dem))
# Simulate individual shocks
v <- rnorm(NS)
# Product characteristics
x <- cbind(1, matrix(rnorm(J*(P-1)), J, P-1))
#x <- matrix(rnorm(J*(P)), J, P)
# Simulate true parameters
alpha <- -1*abs(rnorm(1))
beta <- rnorm(P)
Pi <- matrix(rnorm((P+1)*D), P+1, D)
Sigma <- matrix(rnorm(P+1))
gamma1 <- rnorm(1)
gamma2 <- rnorm(1)
inst_scale <- abs(rnorm(1))
# Simulate prices
# Instrument
instrument <- matrix(rnorm(J*T), J*T, 1)
# Price
price <- gamma1 + gamma2 * instrument + rnorm(J*T, 0, inst_scale)
price_matrix <- matrix(price, T,J, byrow = T)
# Simulate structural shocks
Xi <- matrix(rnorm(J*T), T, J)
# Delta
delta <- matrix(NA, T, J)
for(i in 1:T) {
delta[i,] = t(alpha * price_matrix[i,] + x %*% beta + Xi[i,])
}
# Simulate customer demographics
Dem_array <- array(NA,dim =  c(T,NS, D))
for(i in 1:T) {
Dem_array[i,,] <- Dem
}
# Simulate customer utility for each market
customer_draws <- array(NA, dim = c(T, NS, J))
market_shares <- matrix(NA, T, J)
for(i in 1:T) {
random_shocks <-  Dem_array[i,,] %*% t(Pi) +  v %*% t(Sigma)
del <- matrix(rep(delta[i,], NS), NS, J, byrow = T)
for(j in 1:J) {
customer_draws[i,,j] <-  del[,j] + random_shocks %*% c(price_matrix[i,j], x[j,]) + rgumbel(NS, loc = -.5772)
}
customer_draws[i,,] <- exp(customer_draws[i,,]) / matrix(rep(rowSums(exp(customer_draws[i,,])), J), NS, J)
market_shares[i,] <- colMeans(customer_draws[i,,])
}
market_shares_est <- market_shares[,-J]
J_est <- J-1
price_est <- as.vector(t(price_matrix[,-J]))
instrument_est <- as.vector(t(matrix(instrument, T, J, byrow = T)[,-J]))
x_est <- x[-J,]
test_est_2 <- optimizing(compiled_blp_dirichlet, data = list(J = J_est,
T = T,
NS = NS,
P = P,
P2 = P2,
D = D,
market_shares = market_shares,
price = price_est,
instruments = matrix(instrument_est),
x = x_est,
Dem = Dem_array,
lambda = exp(3),
lambda2 = 3))
pars <- test_est$par
pars <- test_est_2$par
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
gamma1
pars[grep("gamma1", names(pars))]
gamma2
pars[grep("gamma2", names(pars))]
test_est$par[1]
test_est_2$par[1]
a <- as.vector(matrix(pars[grep("predicted_shares", names(pars))], 20, 10))
b <- as.vector(market_shares)
cor(scale(b - a), as.vector(Xi))
plot(as.vector(pars[grep(x = names(pars),"Xi")]), as.vector(Xi[,-J]))
plot(as.vector(test_est_2$par[grep(x = names(test_est_2$par),"Xi")]), as.vector(Xi[,-J]))
plot(scale(b - a), as.vector(Xi))
compiled_blp_dirichlet
compiled_blp_dirichlet <- stan_model("models/blp_dirichlet2.stan")
test_est_2 <- optimizing(compiled_blp_dirichlet, data = list(J = J_est,
T = T,
NS = NS,
P = P,
P2 = P2,
D = D,
market_shares = market_shares,
price = price_est,
instruments = matrix(instrument_est),
x = x_est,
Dem = Dem_array,
lambda = exp(3),
lambda2 = 3))
pars <- test_est_2$par
alpha
pars[grep("alpha", names(pars))]
beta
pars[grep("beta", names(pars))]
a <- as.vector(matrix(pars[grep("predicted_shares", names(pars))], 20, 10))
b <- as.vector(market_shares)
plot(scale(b - a), as.vector(Xi))
library(rstan)
expose_stan_functions("models/blp.stan")
